% Preamble starts here
\documentclass[utf8,english]{gradu3}

\usepackage{xcolor}

% NOTE: This must be the last \usepackage in the whole document!
\usepackage[bookmarksopen,bookmarksnumbered,linktocpage]{hyperref}

\addbibresource{thesis.bib} % The file name of your bibliography database

% My custom macros
\newcommand{\todo}[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\tmp}[1]{\textit{{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Actual document begins here
\begin{document}

\title{Maintainability in cloud-native architecture}
\translatedtitle{Ylläpidettävyys pilvinatiiveissa arkkitehtuureissa}
\studyline{Software and Telecommunication Technology}
\avainsanat{%
  ylläpito,
  ylläpidettävyys
  julkinen pilvi,
  pilvinatiivi,
  pilviarkkitehti,
  arkkitehtuuri,
  ohjelmistoarkkitehtuuri,
  pro gradu -tutkielmat
}
\keywords{%
  maintenance,
  maintainability,
  public cloud,
  cloud-native,
  cloud architect,
  architecture,
  software architecture,
  Master's Theses}
\tiivistelma{%
  Tutkielman tavoitteena on selvittää kuinka ylläpidettävyys huomioidaan
  pilvinatiivien sovellusten arkkitehtuurisuunnitteluvaiheessa.  Tämän
  saavuttamiseksi suoritan kyselyn Nordcloud-yrityksen pilviarkkitehtien
  keskuudessa.  Ensin määritän kuinka tärkeänä ylläpidettävyyttä pidetään.
  Sitten kategorisoin ehdotukset ylläpidettävyyden huomioimiseen, ja suhteutan
  ne vastaajien kokemuksen määrään kohdealueelta. Lopuksi vertaan kyselyn
  tuloksia kirjallisuudessa ehdotettuihin lähestymistapoihin.
}
\abstract{%
  Goal of the thesis is to investigate how maintainability is addressed during
  the architectural design phase of cloud-native software development lifecycle.
  To this end, I conducted a survey among cloud architects of company Nordcloud,
  where I work.
  First I ascertain the perceived importance of maintainability.
  Then I categorize the suggested approaches for addressing maintainability and
  relate this to the respondents' years of experience in the target domain.
  Finally, I compare the survey results to approaches suggested in the literature.
}

\author{Juho Kettunen}
\contactinformation{\texttt{juho.kettunen@student.jyu.fi}}
\supervisor{Oleksiy Khriyenko}

\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thetermlist}
  \item [Test] Term explanation
\end{thetermlist}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}


Goal of the thesis is to investigate how maintainability is addressed during
the architectural design phase of cloud-native software development lifecycle.
I chose this topic for three reasons:
\begin{enumerate}
  \item Choices made during the architectural design phase cascade into
        development and maintenance phases.
        Mistakes and oversights are slower and more expensive to correct later. \parencite{Bass1998}
  \item Maintenance phase of the software lifecycle is prevalent.
        It takes up the majority of total lifetime and costs. \parencite{Bass1998}
  \item Cloud-native approach helps reduce time-to-market and move costs from
        capital expenditure to operational expenditure. \todo{<SOURCE?>}
        Utilizing a public cloud platform allows the company to leverage a
        highly scalable, reliable and secure infrastructure and a wide variety
        of easily integratable services. \todo{<SOURCE?>}
\end{enumerate}

\todo{REWRITE! Check thesis template for good suggestions}
\tmp{First I will ascertain the perceived importance of maintainability.
  Then I will categorize the suggested approaches for addressing maintainability
  and contrast this to the respondents' years of experience in the target domain.
  Finally, I will compare the survey results to approaches suggested in the literature.}

\todo{last thing: thesis structure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

My main database for researching existing literature was the JYKDOK search engine for international articles \parencite{JYKDOK}.
I decided to search keywords in abstracts, instead of full-text or only in title.
In my opinion the full-text search was too lax, and title-only too strict.
With these search terms I received between 4 to 473 results per search, which was sufficient:
\begin{itemize}
  \item (Abstract:''cloud native'' AND Abstract:maintainability)
  \item (Abstract:''cloud native'' AND Abstract:architecture)
  \item (Abstract:''cloud native'' AND Abstract:maintenance)
  \item (Abstract:architecture AND Abstract:maintainability AND Abstract:cloud)
  \item (Abstract:serverless AND Abstract:maintainability)
  \item (Abstract:serverless AND Abstract:operations)
  \item (Abstract:''cloud-native'' AND Abstract:quality AND Abstract:attribute)
  \item (Abstract:software AND Abstract:''quality attribute'' AND Abstract:maintainability)
\end{itemize}

To my chagrin, I was unable to find full-text of some articles with promising abstracts.
In case of one specific article I emailed the authors \footnote{\textcite{Bogner2018}}, and they kindly sent me a PDF of it.

I also employed an ad-hoc lightweight version of snowballing from bibliographies of
promising sources, e.g. \todo{example here?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architecture as a software licecycle phase}

\subsection{Software architecture}

What is software architecture? We can begin by stating that every software
system has one. The architecture exists even if no-one present knows any details
about it \parencite[24]{Bass1998}. \textcite[23]{Bass1998} provide us a
definition as follows:

\begin{quote}
  The software architecture of a program or computing system is the structure or
  structures of the system, which comprise software elements, the externally
  visible properties of those elements, and the relationships among them.
\end{quote}

A \textbf{software system} is a collection of software components organized to accomplish
a specific function or set of functions \parencite[3]{IEEE42010}. These components --- or
elements --- can be entities of varying size: objects, processes, libraries,
databases, commercial software, and so on. In its most trivial case, we can
consider the entire system to be a single component. This is indeed an
architecture, but practically useless due to lack of necessary details
\parencite[24]{Bass1998}. A software architect is a person, team or organization
responsible for systems architecture \parencite[3]{IEEE42010}.

\textcite[53]{Koskimies2005} define a \textbf{component} as an individual software
unit that offers its services through well-defined interfaces. Implementation
details of the components are not considered part of architecture, but their
interactions are. Without describing the interactions we end up with a ''bubbles
and lines'' diagram which is not sufficient to describe an architecture
\parencite[24]{Bass1998}.

A system can comprise more than one structure \parencite[23]{Bass1998}. Because
''structure'' is an abstract concept, it can change depending on perspective. A
\textbf{architectural view} models some aspect of the system \parencite{Koskimies2005}. It is a
representation of a whole system from the perspective of a related set of
concerns, such as a specific stakeholder's specific concern \parencite[3]{IEEE42010}. A
\textbf{stakeholder} is an individual, team or organization with interests in, or
concerns relative to, a system. Examples include clients, users, the architect,
developers, reviewers, and so on. \parencite[3]{IEEE42010}. Examples of architectural
views include a scenario view, logical view, process view,
development view, physical view, and modification view. They are partly
overlapping: when a specific part of a system is changed, we often need to apply
changes in multiple views. \parencite{Koskimies2005}.

Architecture represents the first design decisions of a system \parencite{Bass1998}. It is
difficult to get it right the first time, and can be laborious to alter down the
road. In worst case, there is a need for an architectural change, which might
result in changes across the entire system and changes to interaction between
components. If we instead can limit the change to a group of components or only
a single one, the change will be easier to carry out. \parencite[31]{Bass1998}

Out of most design artifacts, architecture has most far-reaching consequences
\parencite[31]{Bass1998}. It will place constraints on implementation and
maintenance: will the system support the required functions;
how easy is it to test, maintain, change and extend; how large data masses can
it process, and so on \parencite{Koskimies2005}.

The architecture might even have effect on the development organization by
nudging towards a specific way to divide tasks to teams by structure of its
components \parencite[31]{Bass1998}. This is somewhat contrary to Conway's law
\footnote{https://en.wikipedia.org/wiki/Conway\%27s\_law} which states that the
technical structure of a system will reflect the social boundaries across the
organizations that produced it. I suppose that in an agile organization the
social structure is malleable enough to be impacted by a new system, when new
teams need to be formed to facilitate the development.

According to \textcite{Koskimies2005}, architecture lies on a higher
abstraction level than implementation. The lower abstraction level of a system
manifests as source code \parencite[24]{Bass1998}. This might be named as ''the
implementation'', or ''design'' as named in \textcite{IEEE12207}. Also \textcite[4]{IEEE42010} states
that architecture is conceptual instead of concrete. This goes hand in hand with
the used vocabulary. With architecture, we are using the vocabulary of the
solution, and are further away from the problem domain than during
implementation \parencite{Koskimies2005}.

When selecting a reference architecture or a fundamental
architectural style, we are dealing with a generic solution that will be further
specified later. An \textbf{architectural style} is a general, high-level guideline for
structuring the components and their responsibilities \parencite[24]{Bass1998}. For
example, client-server architecture is an architectural style. It is not an
architecture in itself: terminology is generic or domain-specific, and the style
is not specific enough to address the requirements set for your new system.
Countless different kinds of architectures can be implemented with the same
architectural style. \parencite[24]{Bass1998}.

As we've read, architecture is of utmost importance for the implementation and
future of the system. Because of this, it seems common sense to document
it somehow. \textcite[24]{Bass1998} define an \textbf{architectural description (AD)} as a
collection of products to document an architecture \parencite[3]{IEEE42010}. As such, it
is a concrete artifact. They go on to note that an architecture can live
independently of its description or specification \parencite[24]{Bass1998}. \textcite[27]{Bass1998}
outscope the documentation of guiding processes from actual architecture.  In
contrast, \textcite[3]{IEEE42010} mentions ''... and principles guiding its design and
evolution''. The standard states that chosen architectural concepts, as well as
considered alternatives, must be justified in the description. According to
\textcite[67]{IEEE12207}, the description can be utilized at multiple different levels of
abstraction, at each level emphasizing the details necessary for that level. If
an AD is not available, it can be reverse-engineered from an existing system.
This might be needed if, for example, it was originally developed without a
description, or if the original architect is no longer available for
consultation. \parencite[7]{IEEE42010}.

An architecture doesn't spawn out of nothing. Software architecture is based on,
among other things, the requirements placed on it \parencite{Bass1998}. Requirements
codify the collective wishes and needs that various stakeholders want from the
system. If requirements were the only input to software development, then an
identical set of requirements would result in two pieces of identical
architectures, even from two entirely unrelated organizations. \parencite[5-9]{Bass1998}.

As we can see, the organization, architect or architects, and the technical
environment greatly influence how software systems are built \parencite{Bass1998}. The
organization might have other existing products, architectures or assets that
can be utilized. The organization has some individual structure, goals and
long-term investments, and personnel with specific skills and availability.
Especially the architects' background and experience is pivotal in deciding the
course for the architecture. The architect might lean on a familiar
architectural style that they have had success with in the past, and vice versa
with an unhappy experience. Their professional community can infuse into the new
system a set of standard industry practices and software engineering techniques.
\parencite[5-9]{Bass1998}.

The architecture cause feedback to its background factors, such as the
organization, customers, architects and the software engineering culture in
general \parencite{Bass1998}. Because an architecture dictates the structure of a software
system, it influences the structure of the development project with respect to
team formation, schedules and budgets. If the architecture is seen as
successful, it might be used in future projects, and then the team structure
might become a permanent part of the organization. The software might also offer
a foothold in a certain market area, and this way the organization could update
its goals to take advantage of this new possibility. Customers will likely grow
fond of a good software product, which lowers the threshold for reusing a
battle-tested architecture, because this is more economical than building a new
one from scratch. The architects themselves gain more experience from this
specific system, which means that the system's success or failure will affect
architectural choices made in future projects. When looking through a wider
lens, an especially novel and successful architecture might influence the
software engineering culture as a whole, outside of the organization from which
is sprung. Imagine, for example, the tides created by the first relational
databases, spreadsheets, windowing systems, or WWW itself. \parencite[10-11]{Bass1998}.


\subsection{Software life cycle}
Every software system has a life cycle \parencite[17]{IEEE12207}. A \textbf{life cycle model} is a
framework that contains the processes, activities and tasks used during the life
of the system, from initial requirements gathering to the termination of its use
\parencite[3]{IEEE42010}. The specific life cycle stages depend on the chosen life cycle
model, of which there are many to choose from: incremental, spiral, iterative,
evolutionary, and so on. Usually there is an initial planning stage, where the
need for a new software system arises. After the need is verified, requirements
are gathered. Next there might be a prototyping phase where multiple
architectures are rapidly mocked and evaluated. Once a rough architectural
direction is chosen, an initial architectural definition is formed. After it is
validated, there often follows an iterative cycle where analysis, design,
implementation, verification, validation and delivery are repeated and
intertwined. \parencite[18]{IEEE12207}.

\textcite{Koskimies2005} suggest an architecture-oriented software
development process. It highlights architectural design and evaluation as a
crucial life cycle stage before moving onto detailed design and implementation.
Architecture should be devised incrementally and iteratively from the
requirements most relevant to architecture. Usually it is good to start from
functional requirements, after which the non-functional qualities must be
pursued. \parencite{Koskimies2005}.

In this thesis I don't cling to any particular software lifecycle model.
Instead we rely on the general notion that the initial architecture definition
and architectural design happens early on in the life cycle of a software
system. Naturally, the requirements, architecture or detailed design might need
refinement also later on during operations and maintenance when using an
iterative life cycle model \parencite{IEEE12207}. We will focus on the early choices and
design decisions that influence the activities for the rest of the software
lifecycle. We can call these architectural activities as ''architecting'', which
comprises defining, documenting, maintaining, improving and certifying proper
implementation of an architecture \parencite[3]{IEEE42010}. In addition to these
architecting activities, \textcite[12]{Bass1998} mention creating a business case
for the system, and implementing the system based on the architecture.

\textcite{IEEE12207} defines processes related to architecture and design. Next we will
make a distinction between two related but separate processes: the \textbf{Architectural
  Definition process}, and the Design Definition process. The purpose of the
Architectural Definition process, as outlined in \textcite[66]{IEEE12207}, is threefold.
First, the architect should create alternatives for a system's architecture.
Then, we should choose one or multiple alternatives that properly frame the
stakeholders' needs and fulfill the requirements placed on the system. Lastly,
all of this should be described with a set of uniform views.

At a lower abstraction level, the \textbf{Design Definition process} \parencite[71]{IEEE12207} is
supposed to provide enough detailed data and information about the system and
its components for implementation to be in line with the architectural entities.
It involves preparing for software system design definition by e.g. prioritizing
design principles and characteristic, identifying and planning for necessary
enabling systems and services, and obtaining access to those enabling systems or
services. Then we should establish designs related to each software element.
This goes deep in the technical details, such as database structures, provisions
for memory and storage, software processes, and external interfaces. \parencite[72]{IEEE12207}.
In this thesis I consider this realm of ''design'' or ''detailed design'' to
belong to software developers instead of architects.

As we've discussed before, architecture is at a higher level of abstraction than
design \parencite{IEEE12207}. Architecture focuses on suitability, viability and
desirability that the architecture is supposed to provide. Meanwhile, design is
focused on compatibility with technologies and other design elements, and
feasibility of implementation and integration. An efficient architecture is as
design-agnostic as possible, to provide most flexibility in planning the said
design.\parencite[71]{IEEE12207}. Because ''design'' is such an ambiguous word, in this
thesis I will use it in accordance to the definition from \textcite{IEEE12207} as an activity
separate from architecting, unless used in conjunction with with ''architectual'',
as in ''architectual design''.

According to \textcite[71-72]{IEEE12207}, selecting the technologies for implementation
and considering compatibility with technologies also falls under the Design
Definition process. In my experience with public cloud providers such as Amazon
Web Services, Microsoft Azure and Google cloud, implementation technologies are
at least to some degree decided by architects instead of software developers.
The architect wants to know which cloud platform is required or preferred by the
customer, in order to reduce the technology space to a reasonable set of
alternative services provided by the platform. The architect can then work with
the available services to compose an architecture that best serves the
stakeholders' needs. The finer details, such as the choice of programming
language or code-level design patterns, can be left to software developers, as
also implied by the ISO/IEC standards.

\textbf{Maintenance stage} is a phase in software life cycle that is often considered
less glamorous than working on greenfield projects and building the next
software hit. Despite this, it is generally accepted that a substantial portion
of the total cost of software is spent on maintenance. \textcite[32]{Bass1998} go as far
as to say this figure is close to 80\%. Obviously the actual numbers might be
slightly different these days 25 years after their estimate, but the implication
holds: considering maintenance efforts as early as possible in the software life
cycle can pay off. \textcite[1]{Mumtaz2021} echo that architectural issues should be
tackled in a timely manner, because the cost of fixing those kinds of problems
later can be exceptionally high.

\textcite{IEEE12207} outlines the \textbf{Maintenance process}, which in general comes later in the
life cycle after Architectural Definition and Design Definition processes. Its
purpose is to sustain the capability of the system to provide a service. This
can be achieved by monitoring the system's capability to deliver services;
recording incidents for analysis; taking corrective, adaptive, perfective and
preventive actions; and confirming restored capability. In practice, preparing
for maintenance should begin already during architecting. It is necessary to
consider constraints placed on the architecture by maintenance-related
requirements. This can be done, for example, by emphasizing encapsulation,
modularity, and scalability. Documenting the architecture and system reduces the
efforts required to reverse-engineer the system and components when a fix is
needed. The decisions made during architecting can also affect the need and
possibilities for e.g. remote diagnostics and maintenance, roll back, backup,
and recovering data. \parencite[95-96]{IEEE12207}.

Tasks performed during maintenance activities vary between systems and
organizations. There is a need to review stakeholder requirements, complaints,
events, incident and problem reports in order to identify the type of
maintenance effort needed \parencite{IEEE12207}. If the organization has adopted an
iterative software life cycle model, software requirements might change during
maintenance. This change in requirements can be a source for adaptive and
perfective maintenance activities. In that case there will be a need to make
corrections, improvements or other changes to software that is already deployed
\parencite[97]{IEEE12207}. As \textcite[32]{Bass1998} points out, having a good grasp of the
architecture will help manage changes and reason about them.


\subsection{General advice for achieving a good architecture}

Because every system has an architecture, you can create an architecture through
the simple method of trial and error. Unfortunately, an architecture built this
way is unlikely to fulfill the requirements and goals placed on it \parencite[24]{Bass1998}.
He outlines some helpful advice for creating an architecture from the
correct principles. These rules of thumb are divided into two categories:
process-related and structure-related advice.

First we will delve into the \textbf{process-related} topics. As a general rule, there
should be a single architect or a team of architects with a designated leader
\parencite[15]{Bass1998}. Functional requirements and a prioritized list of quality
attributes should be listed, so that the architecture can be steered towards
achieving them. The architecture should be formally evaluated for quality
attributes, and analyzed for applicable quantitative measures, such as maximum
throughput. Having an architecture support iterative implementation makes
integration and testing easier: a ''skeleton system'' can prove that component
communication works, even with otherwise minimal functionality. The architect is
also responsible for defining, distributing, maintaining and enforcing resource
constraints to the responsible implementation teams. For example, there might be
limits to network traffic or hardware performance that the teams must heed. A
good documentation is also a must, with at least one static view and one dynamic
view, written in a notation that all stakeholders can understand with minimal
effort. Speaking of stakeholders, they should be actively participating in
evaluating the architecture, to ensure their needs are being met. \parencite[15]{Bass1998}.

Next up are the \textbf{structure-related} pieces of wisdom. \textcite[16]{Bass1998} state that
modules should be well defined, with a clear separation of concerns and
following the principles of information hiding. Their interfaces should also be
well defined, and encapsulate any details that might change during
implementation, such as choice of data structures. To improve modifiability, the
modules that produce data should be kept separate from those that consume data.
Between the modules, there should be only a small set of different ways of
interaction, which is to say, the system should perform similar tasks in a
similar fashion all around. This helps improve understandability, reliability
and modifiability, with an added benefit of shorted development time and
conceptual integrity of the architecture. Each quality attribute should be
strived towards with well known architectural tactics that suit it. The
architecture should not depend on any specific version of a commercial product
or tool, or if it does, changing the product or tool should be both
straightforward and cheap. If working close to hardware, changing the processor
allocated for each task or process should be easy even at runtime. In case of
parallel-processing systems, special care should be given to processes or tasks
that touch multiple modules. \parencite[16]{Bass1998}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maintainability}

\subsection{Quality Attributes}

The main goal of software development is software of high quality. We of course
expect that the system fulfills all its requirements, gives us correct and
accurate results, and that it interacts with other systems in an expected manner
\parencite[76]{Bass1998}. According to \textcite[602]{Gorla2010}, this quality
can be influenced by factors that are \textbf{organizational}, \textbf{technological},
or \textbf{end user-related}. Organizational factors can include the IT budget, number of people
in system development in that organization, and quality of documentation. Level of
user involvement and user training the systems are end user-related factors. In
contrast, technological factors include experience and skill level of the
development staff, and type and suitability of development method, programming
language or database model. \parencite[602]{Gorla2010}. Few factors outside the
technological category are relevant in this thesis, which is why I mostly --
although not exclusively -- focus on factors that can be influenced by the
software architect.

\textbf{Quality attributes} are used to describe specific aspects of quality as it
relates to software. From management perspective, we are likely interested in
business-related attributes and metrics such as cost and effort of development
work, productivity estimation, and time-to-market
\parencites[60]{Arvanitou2017}[76]{Bass1998}.
In this thesis I only deal with these topics at a superficial level, as
they cannot be directly quantified based on architecture alone. \textcite[76]{Bass1998}
suggest that there are two categories of quality attributes that instead can be
measured on architectural level: attributes that \textbf{can be observed by running the
  system}, and those that cannot. The first category tells us how well the system
fills its behavioral requirements during runtime. Quality attributes that
indicate this include \parencites[79-81]{Bass1998}[13]{Li2021}[60]{Arvanitou2017}:
\begin{itemize}
  \item performance
  \item security
  \item availability
  \item functionality
  \item usability
  \item monitorability
  \item reliability
  \item safety
  \item fault prediction
  \item defect proneness
\end{itemize}

The second category of quality attributes --- those that \textbf{cannot be observed by
  running the system} --- tell us how easy the system is to test, integrate and
modify \parencite[81]{Bass1998}. It contains, among others, these attributes:
\begin{itemize}
  \item modifiability
  \item portability
  \item reusability
  \item integrability
  \item testability
\end{itemize}

Other authors use related terms ''functional'' and ''non-functional requirements''.
\textcite[76]{Bass1998} consider this dichotomy useless. It
suggests that all attributes can be divided strictly into those that model the
system's ability to perform the actions it is expected to, and ''everything
else''. The latter non-functional category acts as a bucket. This too easily
leads to a situation where some qualities are given less consideration, leading
to a diminished quality of the system as a whole. In fact, many quality
attributes are intertwined to behavior of the system. For example, it might be
impossible to reach lightning fast performance with a feature that processes
very large images. On a higher level, though, Bass et al consider functionality
to be orthogonal to quality attributes. If this wasn't the case, implementing a
certain functionality would always dictate the system's security, usability, or
other attributes. The program might function perfectly, but it might
also be difficult to modify or costly to build. \parencite[77]{Bass1998}.

Instead, architectural choices made by the architect decide the level of quality
possible for the system \parencite[72]{Bass2003}. Quality must be considered at every
stage of design, implementation and deployment \parencite{Bass1998}. Different quality
attributes represent themself differently at different stages. For example, some
usability decisions, such as details of a UI, are not architectural at all.
Modifiability, on the other hand, is primarily architectural. Modifiability
relates to how a system is split into components, and a system is modifiable if
changes do not require touching multiple components. Performance depends on both
architectural and non-architectural considerations. Architect can influence how
functionality is divided between each component, and how they communicate. But
the finer details are left to developers, who are usually responsible or
detailed design. An example of this is the choice of an algorithm and turning it
into source code. Another thing to consider is that quality attributes do not
exists in a vacuum, but instead influence each other in good or bad \parencite[78]{Bass1998}.
For example, improved monitorability likely enables improved testability,
which in turn leads to an increase in security \parencite[18]{Li2021}. Architect must
prioritize the quality attributes and decide which ones to emphasize
\parencite[129]{Bass1998}.


\subsection{What is maintainability, and why is it important}

The quality attribute \textbf{maintainability} describes the efforts needed to fix errors
or to make enhancements to the system \parencite[603]{Gorla2010}. Based on their mapping
study on design-time quality attributes and metrics, \textcite{Arvanitou2017}
found that maintainability is the most often researched quality attribute in
most stages of the software development life cycle. It receives interest in
design, architecture, implementation and maintenance stages. Maintainability is
especially relevant in other stages such as project management, requirements or
testing stages. \parencite[61-62]{Arvanitou2017}.

Like many other quality attributes, maintainability can be further subdivided
into more specific quality attributes. \textcite[233]{ISO5055} lists \textbf{modularity},
\textbf{reusability}, \textbf{analyzability}, \textbf{changeability},
\textbf{modification stability}, \textbf{testability} and \textbf{compliance} as
components of maintainability. Many of these are also echoed
by \textcite[61]{Arvanitou2017}. Some other categories, such as \textbf{understandability}, are
sometimes related to maintainability. \textcite{Arvanitou2017} consider it a
separate quality attribute for two reasons. First, some other quality models
make a distinction between maintainability and understandability. Second, a
unique research community has already gathered around understandability as a
standalone concept. \parencite[61]{Arvanitou2017}.

There is no single metric ''maintainability of the software system'', because
its components likely have different purposes and implementations
\parencites[26]{Broy2006}[192]{Bass1998}. As such, a phrase like ''the system
is highly maintainable'' doesn't tell anything practical about the system,
because quality attributes receive their meaning from surrounding context. For
example, the software might be highly modifiable in relation to specific classes
of changes. \parencite[192]{Bass1998}.

Focusing on maintainability can pay back the cost invested into it. It
influences how much money and time needs to be spent on maintenance tasks
\parencite[21]{Broy2006}. If it is not considered, cost of change can be
unnecessarily inflated \parencite[2]{Vale2022}. Personnel requirements have to
also be considered, because someone needs to perform necessary updates and
fixes. \textcite{Heroku2011} warns that if maintenance work is left to the one single
team of software developers, the time is often deducted from development of new features.

If a system is not maintainable, it will be more difficult to address other
problems, such as performance or reliability \parencite[46]{Bouwers2010}. If different
services are coupled, one of them cannot be altered without changing others that
are depending on it \parencite[2]{Vale2022}. At the business level, maintainability of an
important system defines the organization's ability to adapt their business
processes to changing market circumstances, and to implement innovative products
and services \parencite[21]{Broy2006}.

Even if the software itself stays unchanged for years, it can break if and when
its environment changes. This phenomenon is called \textbf{software rot}
\footnote{\url{http://www.catb.org/jargon/html/S/software-rot.html}.}.
In other words, software rot happens when a system's assumptions
go out of date. A good example of this is the infamous ''Y2K'' event which
resulted in uncountable bugs when two-digit year counters underwent wrap-around
at the start of the new millennium. Even outside such one-off
situations, software can touch the underlying operating system and network
infrastructure in many places: library versions, directory paths, IP addresses
and hostnames, and so on \parencite{Heroku2011}. The above Jargon File \footnote{The Jargon
File is a ''comprehensive compendium of hacker slang illuminating many aspects
of hackish tradition, folklore, and humor.''
\url{http://www.catb.org/jargon/html/online-preface.html}} entry about software
rot advises to employ robust design to deflect such problems. Based on what
we've discussed in this chapter, I consider taking care of maintainability part
of robust design.


\subsection{How to measure maintainability}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cloud-nativity}

\tmp{Definitions from AWS, Microsoft, Google, CNAF, research...}
\subsection{History}

\subsection{Microservices}

\subsection{Serverless}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maintainability in cloud-native architecture}
\tmp{Tie all the above topics together here}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Method}

In this chapter I present the research method and goals. \todo{more}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Research questions}

I aim to answer three research questions:
\begin{itemize}
  \item [\textbf{RQ1}] How much importance do cloud architects place on maintainability during
        the design phase?
  \item [\textbf{RQ2}] How to address maintainability concerns when architecting cloud-native
        applications?
  \item [\textbf{RQ3}] Do the recommendations from literature match the views of architects
        working in the field?
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Survey}

I conducted a survey that offers real-life insights into the research questions.
Survey manifests as a Google Form.
In the first section there is a data collection disclaimer and a mandatory agree-disagree choice,
before the respondent can proceed to answer the actual questions.


\subsection{Questions}
The first half of the survey gathers some demographic insights.
The latter half is dedicated to the actual subject matter.
These are all the questions, excluding the prerequisite data collection agreement:
\begin{enumerate}
  \item [\textbf{Q1}] Years of experience in cloud-native architecture?
  \item [\textbf{Q2}] Years of experience in software architecture in general?
  \item [\textbf{Q3}] Years of experience in IT in general?
  \item [\textbf{Q4}] How do you prioritize these software quality attributes when designing cloud-native
        architecture?
  \item [\textbf{Q5}] How do you address maintainability with platform- and technology choices?
  \item [\textbf{Q6}] How do you address maintainability with application architecture?
\end{enumerate}

Questions Q1 through Q3 are single-selection questions with these ranges:
\begin{itemize}
  \item 0-2
  \item 2-5
  \item 5-10
  \item 10+
\end{itemize}

Question Q4 offers a selection of software quality attributes:
\begin{itemize}
  \item Performance
  \item Reliability
  \item Maintainability
  \item Scalability
  \item Security
\end{itemize}

The respondent should set these quality attributes in a priority order.
Available priority options are:
\begin{itemize}
  \item Most important
  \item More important
  \item Important
  \item Less important
  \item Least important
\end{itemize}

Questions Q5 and Q6 are open questions, where the respondent can describe their
thoughts through text in any structure they like.
I interpret the answers to find common categories from the suggestions.

\subsection{Target audience}
The survey is targeted at cloud architects of \textit{Nordcloud, an IBM company}, where I work.
I posted the survey link along with an introductory message to Nordcloud's
internal Slack channels to reach most of our cloud architects.
These channels were used:
\begin{itemize}
  \item \#tech-infra
  \item \#aws
  \item \#azure
  \item \#google-cloud
\end{itemize}

Some of these communities have overlapping audience, but the total reach is over a thousand people.
I assume our company to employ a few dozen cloud architects.
My goal was to get 10-20 answers in order to conduct any meaningful statistical analysis on
the data.
This goal was met within a week with 13 answers, with a final tally of \todo{<NUMBER>}.

\subsection{Timeline}
Survey was sent out on Monday 20.03.2023.
I was prepared to repost the survey in Slack once a week up to four times until I
decide I have enough answers to proceed.
In the end there was no need to repost, as a sufficient number of architects
responded after the initial posting.
In early April I was able to convince one additional architect in-person at our
Jyväskylä office to respond.
Some stray responses were still recorded up to 21.4.2023.

\subsection{Data privacy concerns}
I use my JYU Google account for all Google-related functions.
Individual answers and their aggregated analysis will be stored in Google Forms and
Google Sheets in my student account until the end of my study rights and
subsequent removal of the account.

All answers are collected and analyzed anonymously.
Email addresses or other pieces of personal information are not collected.
Even though the form requires logging in with a Google account, it is enforced
only to avoid accidental re-submissions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analysis}

\begin{itemize}
  \item Calculate a relative grade for priority of maintainability based on answers to question Q4.
  \item Interpret and list the suggestions from answers to questions Q5 and Q6.
  \item Normalize the suggestions to find common categories.
  \item Find the most popular categories and point out possible outliers.
  \item Compare categories to solutions proposed in literature.
  \item Bonus: Calculate statistical correlation between years of experience and:
        \begin{itemize}
          \item perceived importance of maintainability
          \item number of categories proposed in Q5 and Q6
          \item popularity of categories proposed in Q5 and Q6
        \end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}

In this section I present the results I gathered from the survey. \todo{more}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Demographics (Q1-Q3)}

\tmp{
  Show the pie diagrams from Google Forms as-is? Table with counts for each option?
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Prioritization of maintainability (Q4)}

To calculate a priority score for each quality attribute, I gave the options an incremental integer value from 1 to 5.
The value 1 corresponds to option \textit{Least Important}, while value 5 corresponds to \textit{Most important}.
The absolute values chosen here are not of importance as long as the difference between each consecutive option is equal,
in order not to introduce additional bias.
This makes our scale analogous to the Likert scale \todo{ref?}, which is often used for questionnaires in research.


\begin{table}[!h]
  \begin{center}
    \caption{Priority options and their numerical weights}
    \label{table:priorities1}
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Priority} & \textbf{Weight} \\
      \hline
      Most important    & 5               \\
      More important    & 4               \\
      Important         & 3               \\
      Less important    & 2               \\
      Least important   & 1               \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

Table \ref{table:priorities2} shows the average priorities and other relevant metrics for the quality attributes.

\begin{table}[!h]
  \begin{center}
    \caption{Average priorities and other metrics for the quality attributes}
    \label{table:priorities2}
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      \textbf{QA}     & \textbf{Average} & \textbf{Min} & \textbf{Mode} & \textbf{Max} \\
      \hline
      Security        & 4.07             & 1            & 5             & 5            \\
      Reliability     & 3.80             & 1            & 5             & 5            \\
      Maintainability & 2.67             & 1            & 2             & 4            \\
      Scalability     & 2.27             & 1            & 1             & 5            \\
      Performance     & 2.20             & 1            & 1             & 4            \\
      \hline
    \end{tabular}
  \end{center}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ways to improve maintainability (Q5 \& Q6)}

\tmp{%
  Extract suggestions, split to categories, present here, etc.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experience vs. prioritization of maintainability}

\tmp{should be simple}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experience vs. suggested ways to improve maintainability}

\tmp{Slightly more involved. Which metrics to select?
  \begin{itemize}
    \item number of suggestions?
    \item popularity of suggestions in context of survey?
    \item popularity of suggestions in the wider context of existing research?
  \end{itemize}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Discussion}

In this section I further discuss the results presented in previous chapter.
\tmp{I also consider the existing literature and contrast my results against findings of those who have researched the topic before me.}


In table \ref{table:priorities3} are listed the distances between the average priorities.
Distances are calculated from results shown in table \ref{table:priorities2}.
From these distances we can draw multiple conclusions.
The top two quality attributes, Security and Reliability, are unequivocally the most highly prioritized attributes in the minds of our cloud architects.
The distance between second and third most prioritized attributes is by far the largest individual jump in values.
Maintainability is sitting quite comfortable in the middle of the range.
This likely means it is considered important, but not a priority if sacrifices need to be made to software quality.
Performance and scalability are considered least important items to an almost identical degree.

\begin{table}[!h]
  \begin{center}
    \caption{Average priorities and delta to next highest item}
    \label{table:priorities3}
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{QA}     & \textbf{Average} & \textbf{$\Delta$} \\
      \hline
      Security        & 4.07             & -                 \\
      Reliability     & 3.80             & 0.27              \\
      Maintainability & 2.67             & 1.13              \\
      Scalability     & 2.27             & 0.40              \\
      Performance     & 2.20             & 0.07              \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printbibliography

\nocite{*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix


\end{document}
